<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- â˜…â˜…â˜… iPadæœ€é©åŒ–â‘ ï¼šèª¤æ“ä½œã«ã‚ˆã‚‹æ‹¡å¤§ãƒ»ç¸®å°ã‚’ç¦æ­¢ â˜…â˜…â˜… -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>æœŸæœ«è©¦é¨“ãƒ»æœ€çµ‚ãƒã‚§ãƒƒã‚¯</title>

  <!-- â˜…â˜…â˜… iPadæœ€é©åŒ–â‘¡ï¼šSafariã®UIã‚’æ¶ˆã™ãŸã‚ã®å‘ªæ–‡ â˜…â˜…â˜… -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="æœ€çµ‚ãƒã‚§ãƒƒã‚¯">

  <style>
    /* --- è¶…ãƒ»æœ€å°é™CSSã€iPadæœ€é©åŒ–ç‰ˆã€‘ --- */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Hiragino Kaku Gothic ProN", "ãƒ¡ã‚¤ãƒªã‚ª", Meiryo, sans-serif;
      background-color: #E6F2F7;
      margin: 0;
      padding: 1rem;
      color: #333;
      -webkit-user-select: none;
      user-select: none;
      font-size: 1.125rem;
    }
    .container {
      max-width: 768px;
      margin: 0 auto;
    }
    .screen { display: none; }
    .button {
      display: block;
      width: 90%;
      max-width: 500px;
      margin: 1.5rem auto;
      padding: 1.75rem;
      border-radius: 16px;
      background-color: #4CAF50;
      color: white;
      text-align: center;
      font-size: 1.75rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .button { border: none; -webkit-appearance: none; appearance: none; -webkit-tap-highlight-color: transparent; }
    .question-box {
      background-color: white;
      padding: 2rem;
      margin: 1.5rem 0;
      border-radius: 16px;
      font-size: 1.5rem;
      line-height: 1.7;
    }
    .option-button {
      display: block;
      width: 100%;
      margin-top: 1.25rem;
      padding: 1.25rem;
      border: 2px solid #ddd;
      border-radius: 16px;
      background-color: white;
      font-size: 1.25rem;
      cursor: pointer;
      text-align: left;
    }
    .correct { background-color: #C8E6C9; border-color: #4CAF50; font-weight: bold; }
    .incorrect { background-color: #FFCDD2; border-color: #F44336; }
    .explanation {
      background-color: #FFF9C4;
      padding: 1.25rem;
      margin-top: 1.5rem;
      border-radius: 12px;
      border-left: 6px solid #FFEB3B;
      font-size: 1.1rem;
    }
    .self-eval-container {
        display: flex;
        justify-content: space-around;
        margin-top: 1.5rem;
    }
    .self-eval-button {
      display: inline-block;
      width: 48%;
      padding: 1.25rem;
      border-radius: 12px;
      text-align: center;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.25rem;
    }
    .perfect-btn { background-color: #2196F3; color: white; }
    .review-btn { background-color: #FF9800; color: white; }

    /* --- ç”»é¢å†…ãƒŠãƒ“ï¼ˆæˆ»ã‚‹ï¼‰ --- */
    .topbar { display: flex; justify-content: flex-end; align-items: center; gap: .5rem; }
    .nav-btn { border: none; -webkit-appearance: none; appearance: none; -webkit-tap-highlight-color: transparent; cursor: pointer; padding: .6rem .9rem; border-radius: 10px; background: #1f2937; color: #fff; font-size: 1rem; }
    .nav-btn:active { opacity: .8; }
  </style>
</head>
<body>

  <div class="container">

    <!-- ===== HOMEç”»é¢ ===== -->
    <div id="home-screen" class="screen" style="display:block;">
      <h1 style="text-align: center; font-size: 2.5rem;">æœŸæœ«è©¦é¨“ãƒ»æœ€çµ‚ãƒã‚§ãƒƒã‚¯</h1>
      <div id="mode-select" style="max-width:500px;margin:0.5rem auto 1rem auto;padding:.6rem 1rem;background:#fff;border-radius:12px;border:1px solid #e5e7eb;font-size:1rem;">
        <div style="display:flex;align-items:center;gap:.75rem;flex-wrap:wrap;">
          <strong>å‡ºé¡Œãƒ¢ãƒ¼ãƒ‰:</strong>
          <label style="display:flex;align-items:center;gap:.35rem;">
            <input type="radio" name="mode" value="all" checked>
            <span>å…¨å•</span>
          </label>
          <label style="display:flex;align-items:center;gap:.35rem;">
            <input type="radio" name="mode" value="review">
            <span>å¾©ç¿’ï¼ˆã‚ã‚„ã—ã„ã®ã¿ï¼‰</span>
          </label>
        </div>
      </div>
      <button class="button" type="button" data-subject="english">è‹±èª</button>
      <button class="button" type="button" data-subject="kokugo">å›½èª</button>
      <button class="button" type="button" data-subject="shakai">ç¤¾ä¼š</button>
      <button class="button" type="button" data-subject="rika">ç†ç§‘</button>
    </div>

    <!-- ===== å•é¡Œç”»é¢ ===== -->
    <div id="quiz-screen" class="screen">
      <div class="topbar">
        <button id="back-home-btn" class="nav-btn" type="button">ğŸ  ãƒ›ãƒ¼ãƒ ã¸</button>
      </div>
      <h2 id="quiz-title" style="text-align: center; font-size: 2rem;"></h2>
      <div id="progress-text" style="text-align: center; color: #555; font-size: 1.2rem;"></div>
      <div id="question-box" class="question-box">
        <div id="question-text"></div>
        <div id="options-container"></div>
        <div id="explanation-box" class="explanation" style="display:none;"></div>
      </div>
      <div id="self-eval-container" class="self-eval-container"></div>
      <div id="retry-container" class="self-eval-container" style="margin-top: .5rem;"></div>
    </div>

  </div>

  <script>
    // ===== HOMEãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒã‚’ç¢ºå®Ÿã«æ‹¾ã†ãƒã‚¤ãƒ³ãƒ‰ =====
    function bindHomeButtons() {
      const home = document.getElementById('home-screen');
      if (!home) return;
      const handler = (subj) => (e) => { e.preventDefault(); startQuiz(subj); };
      home.querySelectorAll('.button[data-subject]').forEach(btn => {
        const subj = btn.dataset.subject;
        // å¤šé‡ç™»éŒ²ã‚’é¿ã‘ã‚‹ãŸã‚ä¸€åº¦ã ã‘
        if (!btn.__bound) {
          btn.addEventListener('click', handler(subj), { passive: false });
          btn.addEventListener('touchend', handler(subj), { passive: false });
          btn.__bound = true;
        }
      });
    }

    // ===== 1. å•é¡Œãƒ‡ãƒ¼ã‚¿æœ¬ä½“ï¼ˆæ•™ç§‘ã”ã¨ã«åˆ†å‰²ã—ã€å®‰å…¨è£…ç½®ã‚’è¿½åŠ ï¼‰ =====

    // --- è‹±èªã®å•é¡Œãƒ‡ãƒ¼ã‚¿ ---
    const Q_ENGLISH = [
      { "id": "eng_s01", "type": "choice", "question": "ã€Œãšã£ã¨ã€œã®çŠ¶æ…‹ã§ã™ã€ã¨ã„ã†æ„å‘³ã‚’è¡¨ã™ã€ç¾åœ¨å®Œäº†å½¢ï¼ˆç¶™ç¶šï¼‰ã®åŸºæœ¬çš„ãªå½¢ã¯ã©ã‚Œï¼Ÿ", "options": { "a": "ä¸»èª + have + å‹•è©ã®-ingå½¢", "b": "ä¸»èª + have + been ~", "c": "ä¸»èª + beå‹•è© + éå»åˆ†è©" }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘ç¾åœ¨å®Œäº†å½¢ï¼ˆç¶™ç¶šï¼‰: ä¸»èª + have / has + been ~" },
      { "id": "eng_s02", "type": "choice", "question": "æ¬¡ã®æ–‡ã®( )ã«ã€for ã‹ since ã®ã©ã¡ã‚‰ã‹ãŒå…¥ã‚‹ã‚ˆã€‚\n\nI have been a volunteer ( ) 2000.", "options": { "a": "for", "b": "since" }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘since + æ™‚ç‚¹ (2000å¹´ã¨ã„ã†éå»ã®æ™‚ç‚¹) ãŒãƒ«ãƒ¼ãƒ«ã ã‚ˆã€‚" },
      { "id": "eng_s03", "type": "choice", "question": "ã€Œãƒ¬ã‚¹ãƒˆãƒ©ãƒ³ã‚’çµŒå–¶ã—ã¦ã„ã‚‹ãŠã˜ã•ã‚“ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ã©ã‚Œã‹ãªï¼Ÿ", "options": { "a": "an uncle which runs a restaurant", "b": "an uncle who runs a restaurant", "c": "an uncle runs a restaurant" }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘é–¢ä¿‚ä»£åè©ï¼ˆäººï¼‰: åè©ï¼ˆäººï¼‰+ who + å‹•è©ã€‚äººãŒç›¸æ‰‹ã ã‹ã‚‰ who ã‚’ä½¿ã†ã‚ˆã€‚" },
      { "id": "eng_s04_who_variation1", "type": "choice", "question": "ã€Œæ•°å­¦ãŒå¾—æ„ãªäººã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ã©ã‚Œï¼Ÿ (ã‚¨ã‚¤ã‚´ãƒ©ãƒœ Room46ã‚ˆã‚Š)", "options": { "a": "a person who good at math", "b": "a person who is good at math", "c": "a person is good at math" }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘é–¢ä¿‚ä»£åè©ï¼ˆäººï¼‰: who ã®å¾Œã‚ã«ã¯ã€beå‹•è©(is)ã‚‚ã¡ã‚ƒã‚“ã¨å¿…è¦ã ã‚ˆï¼" },
      { "id": "eng_s05_who_variation2", "type": "choice", "question": "ã€Œæ±ºã—ã¦ã‚ãã‚‰ã‚ãªã„äººã€…ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ã©ã‚Œï¼Ÿ (ã‚¨ã‚¤ã‚´ãƒ©ãƒœ Room46ã‚ˆã‚Š)", "options": { "a": "people who never gives up", "b": "people who never give up", "c": "people never give up" }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘é–¢ä¿‚ä»£åè©ï¼ˆäººï¼‰: å…ˆè¡Œè©(people)ãŒè¤‡æ•°å½¢ã ã‹ã‚‰ã€å‹•è©(give)ã« s ã¯ä»˜ã‹ãªã„ã®ãŒãƒ«ãƒ¼ãƒ«ï¼" },
      { "id": "eng_s06_which_variation1", "type": "choice", "question": "ã€Œå¹¸ã›ãªçµæœ«ã®æ˜ ç”»ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ã©ã‚Œï¼Ÿ (ã‚¨ã‚¤ã‚´ãƒ©ãƒœ Room47ã‚ˆã‚Š)", "options": { "a": "a movie which has a happy ending", "b": "a movie which have a happy ending", "c": "a movie has a happy ending" }, "answer": "a", "explanation": "ã€è™ã®å·»ã€‘é–¢ä¿‚ä»£åè©ï¼ˆãƒ¢ãƒï¼‰: å…ˆè¡Œè©(a movie)ãŒå˜æ•°å½¢ã ã‹ã‚‰ã€å‹•è©ã¯ has ã«ãªã‚‹ã‚ˆï¼" },
      { "id": "eng_a01", "type": "choice", "question": "ã€Œç§ã«ã“ã‚Œã®ä½¿ã„æ–¹ã‚’è¦‹ã›ã¦ã€ã¨ã€ã‚„ã‚Šæ–¹ã‚’è¦‹ã›ã¦ã»ã—ã„æ™‚ã«ä½¿ã†ã®ã¯ã©ã£ã¡ï¼Ÿ", "options": { "a": "tell me how to use this", "b": "show me how to use this", "c": "ask me how to use this" }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘é–“æ¥ç–‘å•æ–‡: show ã¯ã€Œè¦‹ã›ã‚‹ã€ã€tell ã¯ã€Œè¨€ã†ã€ã€‚ã‚„ã‚Šæ–¹ã ã‹ã‚‰ show ãŒãƒ”ãƒƒã‚¿ãƒªï¼" },
      { "id": "eng_a02", "type": "choice", "question": "ã€Œçˆ†å¼¾ãŒè½ã¨ã•ã‚ŒãŸã€ã¨ã€ã€œã•ã‚ŒãŸã€ã¨ã„ã†æ„å‘³ã‚’è¡¨ã™å—å‹•æ…‹ã®æ–‡ã¯ã©ã‚Œï¼Ÿ", "options": { "a": "The bomb dropped.", "b": "The bomb was dropped.", "c": "The bomb is dropped." }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘å—å‹•æ…‹ï¼ˆéå»å½¢ï¼‰: ä¸»èª + was / were + éå»åˆ†è©ã€‚éå»ã®è©±ã ã‹ã‚‰ was ã‚’ä½¿ã†ã‚ˆã€‚" },
      { "id": "eng_a03", "type": "choice", "question": "ã€Œãã®çŸ¥ã‚‰ã›ã¯ç§ã‚’æ‚²ã—ãã•ã›ãŸã€ã¨ã€Aã‚’Bã®çŠ¶æ…‹ã«ã€Œã•ã›ãŸã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ï¼Ÿ", "options": { "a": "The news was sad for me.", "b": "I was sad by the news.", "c": "The news made me sad." }, "answer": "c", "explanation": "ã€è™ã®å·»ã€‘ä½¿å½¹å‹•è© make: make + äºº/ãƒ¢ãƒ + å½¢å®¹è© ã®å½¢ã ã‚ˆã€‚" },
      { "id": "eng_a04_what_to_variation1", "type": "choice", "question": "ã€Œä½•ã‚’é£²ã‚€ã¹ãã‹æ±ºã‚ã‚‰ã‚Œãªã„ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ã©ã‚Œï¼Ÿ (ã‚¨ã‚¤ã‚´ãƒ©ãƒœ Room35ã‚ˆã‚Š)", "options": { "a": "I can't decide what drink.", "b": "I can't decide what to drink.", "c": "I can't decide to what drink." }, "answer": "b", "explanation": "ã€è™ã®å·»ã€‘é–“æ¥ç–‘å•æ–‡: what to + å‹•è©ã®åŸå½¢ ã®å½¢ãŒåŸºæœ¬ã ã‚ˆã€‚" },
      { "id": "eng_sort01", "type": "sort", "question": "æ—¥æœ¬èªã«åˆã†ã‚ˆã†ã«ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’ä¸¦ã¹æ›¿ãˆã¦ã¿ã‚ˆã†ï¼\n\nã€Œç§ã«ã¯ã€åºƒå³¶ã«ä½ã‚“ã§ã„ã‚‹ãŠã˜ãŒã„ã¾ã™ã€", "options": ["lives", "an", "who", "in", "I", "uncle", "have", "Hiroshima."], "answer": ["I", "have", "an", "uncle", "who", "lives", "in", "Hiroshima."], "explanation": "ã€è™ã®å·»ã€‘é–¢ä¿‚ä»£åè©ï¼ˆäººï¼‰: I have an uncle + He lives in Hiroshima. ã‚’ who ã§ç¹‹ã’ã‚‹ã‚ˆï¼" },
      { "id": "eng_sort02_extra", "type": "sort_extra", "question": "æ—¥æœ¬èªã«åˆã†ã‚ˆã†ã«ä¸¦ã¹æ›¿ãˆã‚ˆã†ï¼ãŸã ã—ã€ä¸è¦ãªèªãŒ1ã¤ã‚ã‚‹ã‚ˆã€‚\n\nã€Œã“ã‚Œã¯åºƒå³¶ã¸è¡Œããã®ãƒã‚¹ã§ã™ã€", "options": ["the", "is", "a", "goes", "that", "bus", "this", "to", "Hiroshima."], "answer": ["This", "is", "the", "bus", "that", "goes", "to", "Hiroshima."], "extraWord": "a", "explanation": "ã€Œãã®ãƒã‚¹ã€ã¨ç‰¹å®šã—ã¦ã„ã‚‹ã®ã§ the ã‚’ä½¿ã†ã€‚a ã¯ä¸è¦ã ã‚ˆã€‚" },
      { "id": "eng_vocab_s01", "type": "choice", "question": "ã€Œå¹³å’Œã€ã‚’æ„å‘³ã™ã‚‹è‹±å˜èªã¯ã©ã‚Œï¼Ÿ", "options": { "a": "peace", "b": "piece", "c": "pork" }, "answer": "a", "explanation": "ã€Sç´šå˜èªã€‘peace = å¹³å’Œã€‚pieceã¯ã€Œã‹ã‘ã‚‰ã€ã ã‹ã‚‰é–“é•ãˆãªã„ã‚ˆã†ã«ï¼" },
      { "id": "eng_vocab_s02", "type": "choice", "question": "ã€Œãƒœãƒ©ãƒ³ãƒ†ã‚£ã‚¢ã€ã‚’æ„å‘³ã™ã‚‹è‹±å˜èªã¯ã©ã‚Œï¼Ÿ", "options": { "a": "borantia", "b": "volunteer", "c": "barrier" }, "answer": "b", "explanation": "ã€Sç´šå˜èªã€‘volunteer = ãƒœãƒ©ãƒ³ãƒ†ã‚£ã‚¢ã€‚ã‚¹ãƒšãƒ«ã‚‚æ›¸ã‘ã‚‹ã‚ˆã†ã«ã—ã¦ãŠã“ã†ï¼" },
      { "id": "eng_vocab_s03", "type": "choice", "question": "ã€Œè£…ç½®ã€ã‚„ã€Œæ©Ÿå™¨ã€ã‚’æ„å‘³ã™ã‚‹è‹±å˜èªã¯ã©ã‚Œï¼Ÿ", "options": { "a": "drive", "b": "divide", "c": "device" }, "answer": "c", "explanation": "ã€Sç´šå˜èªã€‘device = è£…ç½®ã€‚AI device (AIè£…ç½®) ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã‚ˆã€‚" },
      { "id": "eng_vocab_s04", "type": "choice", "question": "ã€Œã€œã‚’ç¿»è¨³ã™ã‚‹ã€ã¨ã„ã†æ„å‘³ã®å‹•è©ã¯ã©ã‚Œï¼Ÿ", "options": { "a": "transport", "b": "translate", "c": "transfer" }, "answer": "b", "explanation": "ã€Sç´šå˜èªã€‘translate = ã€œã‚’ç¿»è¨³ã™ã‚‹ã€‚translation software (ç¿»è¨³ã‚½ãƒ•ãƒˆ)ã§è¦šãˆã‚ˆã†ã€‚" },
      { "id": "eng_vocab_a01", "type": "choice", "question": "ã€Œæ”¿åºœã€ã‚’æ„å‘³ã™ã‚‹è‹±å˜èªã¯ã©ã‚Œï¼Ÿ", "options": { "a": "government", "b": "goverment", "c": "govermentt" }, "answer": "a", "explanation": "ã€Aç´šå˜èªã€‘government = æ”¿åºœã€‚n ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«ã€ã‚¹ãƒšãƒ«ãŒè¶…é‡è¦ï¼" },
      { "id": "eng_vocab_a02", "type": "choice", "question": "ã€Œé›£æ°‘ã€ã‚’æ„å‘³ã™ã‚‹è‹±å˜èªã¯ã©ã‚Œï¼Ÿ", "options": { "a": "refuge", "b": "refuse", "c": "refugee" }, "answer": "c", "explanation": "ã€Aç´šå˜èªã€‘refugee = é›£æ°‘ã€‚æ‰åŸåƒç•ã®ç‰©èªã§å‡ºã¦ããŸã­ã€‚" },
      { "id": "eng_vocab_a03", "type": "choice", "question": "ã€Œä¾¿åˆ©ãªã€ã¨ã„ã†æ„å‘³ã®å½¢å®¹è©ã¯ã©ã‚Œï¼Ÿ", "options": { "a": "convinient", "b": "konbini", "c": "convenient" }, "answer": "c", "explanation": "ã€Aç´šå˜èªã€‘convenient = ä¾¿åˆ©ãªã€‚ã“ã‚Œã‚‚ã‚¹ãƒšãƒ«ãŒé›£ã—ã„ã‹ã‚‰è¦æ³¨æ„ï¼" },
      { "id": "eng_vocab_a04", "type": "choice", "question": "ç†Ÿèªã€Œpass ( )ã€ã§ã€ã€Œã€œã‚’ä¼ãˆã‚‹ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ï¼Ÿ", "options": { "a": "in", "b": "on", "c": "out" }, "answer": "b", "explanation": "ã€Aç´šç†Ÿèªã€‘pass on = ã€œã‚’ä¼ãˆã‚‹ã€‚pass out ã¯ã€Œæ°—çµ¶ã™ã‚‹ã€ã ã‹ã‚‰å…¨ç„¶é•ã†æ„å‘³ã ã‚ˆã€‚" },
      { "id": "eng_vocab_a05", "type": "choice", "question": "ç†Ÿèªã€Œtake ( )ã€ã§ã€ã€Œè¡Œå‹•ã‚’èµ·ã“ã™ã€ã¨ã„ã†æ„å‘³ã«ãªã‚‹ã®ã¯ï¼Ÿ", "options": { "a": "action", "b": "act", "c": "actor" }, "answer": "a", "explanation": "ã€Aç´šç†Ÿèªã€‘take action = è¡Œå‹•ã‚’èµ·ã“ã™ã€‚ã“ã‚Œã¯ã‚»ãƒƒãƒˆã§è¦šãˆã‚ˆã†ï¼" }
    ];

    // --- å›½èªã®å•é¡Œãƒ‡ãƒ¼ã‚¿ ---
    const Q_KOKUGO = [
      { id: "koku_01", type: "choice", question: "ã€Œæ˜é¡æ­¢æ°´ã€ã®èª­ã¿æ–¹ã¯ï¼Ÿ", options: { a: "ã‚ã„ãã‚‡ã†ã—ã™ã„", b: "ã¿ã‚‡ã†ãã‚‡ã†ã—ã™ã„" }, answer: "a", explanation: "åŸºæœ¬çš„ãªå››å­—ç†Ÿèªã§ã™ã€‚" }
    ];

    // --- ç¤¾ä¼šã®å•é¡Œãƒ‡ãƒ¼ã‚¿ ---
    const Q_SHAKAI = [
      { id: "sha_01", type: "choice", question: "è‡ªç”±æ°‘æ¨©é‹å‹•ã®ä¸­å¿ƒäººç‰©ã¯ï¼Ÿ", options: { a: "æ¿å£é€€åŠ©", b: "ä¼Šè—¤åšæ–‡" }, answer: "a", explanation: "åœŸä½è—©å‡ºèº«ã®äººç‰©ã§ã™ã€‚" }
    ];

    // --- ç†ç§‘ã®å•é¡Œãƒ‡ãƒ¼ã‚¿ ---
    const Q_RIKA = [
      { id: "rika_01", type: "choice", question: "æ¸›æ•°åˆ†è£‚ã§ã€æŸ“è‰²ä½“ã®æ•°ã¯ã©ã†ãªã‚‹ï¼Ÿ", options: { a: "2å€ã«ãªã‚‹", b: "åŠåˆ†ã«ãªã‚‹", c: "å¤‰ã‚ã‚‰ãªã„" }, answer: "b", explanation: "ç”Ÿæ®–ç´°èƒãŒã§ãã‚‹ã¨ãã®åˆ†è£‚ã§ã™ã€‚" }
    ];

    // --- å®‰å…¨è£…ç½®ï¼ˆChatGPTææ¡ˆï¼‰---
    function deepFreeze(o){ Object.freeze(o); Object.getOwnPropertyNames(o).forEach(k=>{ const v=o[k]; if(typeof v==="object"&&v!==null&&!Object.isFrozen(v)) deepFreeze(v); }); return o;}
    function ensureUniqueIds(groups){ const seen=new Set(); for(const [subj, arr] of Object.entries(groups)){ for(const q of arr){ if(seen.has(q.id)) { console.error(`IDé‡è¤‡: ${q.id} (${subj})`); } seen.add(q.id); } } }

    // --- ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆ ---
    const ALL_QUESTIONS = {
      english: Q_ENGLISH,
      kokugo: Q_KOKUGO,
      shakai:  Q_SHAKAI,
      rika:    Q_RIKA,
    };
    ensureUniqueIds(ALL_QUESTIONS);
    deepFreeze(ALL_QUESTIONS);

    // ===== 2. ã‚¢ãƒ—ãƒªã®ä¸»è¦ãªå¤‰æ•° =====
    const STATUS = { PERFECT: 'perfect', REVIEW: 'review' };
    const SUBJECT_NAMES = { english: 'è‹±èª', kokugo: 'å›½èª', shakai: 'ç¤¾ä¼š', rika: 'ç†ç§‘' };
    let currentSubject = '';
    let currentQuestions = [];
    let currentIndex = 0;
    let progress = {};
    let statsSubjectKey = ''; // ç¾åœ¨ç§‘ç›®ã®é€²æ—ä¿å­˜ã‚­ãƒ¼ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ç”¨ï¼‰

    // ===== 3. ä¸»è¦ãªDOMè¦ç´  =====
    const homeScreen = document.getElementById('home-screen');
    const quizScreen = document.getElementById('quiz-screen');
    const quizTitle = document.getElementById('quiz-title');
    const progressText = document.getElementById('progress-text');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const explanationBox = document.getElementById('explanation-box');
    const selfEvalContainer = document.getElementById('self-eval-container');
    const retryContainer = document.getElementById('retry-container');
    const backHomeBtn = document.getElementById('back-home-btn');
    const modeSelect = document.getElementById('mode-select');

    // â˜…â˜…â˜… å®‰å…¨ãªãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºé–¢æ•° â˜…â˜…â˜…
    function setQuestionText(el, text) {
      const esc = String(text).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      el.innerHTML = esc.replace(/\n/g, "<br>");
    }

    // ===== 4. ã‚¯ã‚¤ã‚ºã®ãƒ­ã‚¸ãƒƒã‚¯ =====
    function getSelectedMode(){
      const sel = modeSelect ? modeSelect.querySelector('input[name="mode"]:checked') : null;
      return sel ? sel.value : 'all';
    }

    function startQuiz(subject) {
      currentSubject = subject;
      const startMode = getSelectedMode();
      statsSubjectKey = 'progress_' + currentSubject;
      loadProgress();
      
      if (!progress || typeof progress !== 'object') progress = {};
      if (!progress.statuses || typeof progress.statuses !== 'object') progress.statuses = {};
      if (!progress.stats || typeof progress.stats !== 'object') progress.stats = {};

      const allQs = ALL_QUESTIONS[subject];
      const reviewQuestions = allQs.filter(q => q.type === 'choice' && progress.statuses[q.id] === STATUS.REVIEW);

      if (startMode === 'review') {
        progress.isReviewMode = true;
        currentQuestions = reviewQuestions.length > 0 ? reviewQuestions : [];
      } else {
        progress.isReviewMode = false;
        currentQuestions = allQs;
      }

      // éå¯¾å¿œã‚¿ã‚¤ãƒ—ï¼ˆä¸¦ã¹æ›¿ãˆãªã©ï¼‰ã¯ç¾è¡ŒUIã§ã¯æœªå¯¾å¿œã®ãŸã‚é™¤å¤–
      currentQuestions = currentQuestions.filter(q => q.type === 'choice');

      // ç©ºã®å¾©ç¿’ãƒªã‚¹ãƒˆã ã£ãŸå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆå…¨å•ã«è‡ªå‹•åˆ‡æ›¿ï¼‰
      if (progress.isReviewMode && currentQuestions.length === 0) {
        progress.isReviewMode = false;
        currentQuestions = allQs.filter(q => q.type === 'choice');
      }

      if (currentIndex < 0 || currentIndex >= currentQuestions.length) {
        currentIndex = 0;
      }
      
      showScreen('quiz');
      displayQuestion();
    }

    function displayQuestion() {
      if (currentIndex >= currentQuestions.length) {
        handleQuizEnd();
        return;
      }

      const q = currentQuestions[currentIndex];
      quizTitle.textContent = SUBJECT_NAMES[currentSubject] || currentSubject;
      progressText.textContent = `${currentIndex + 1} / ${currentQuestions.length} å•`;
      
      setQuestionText(questionText, q.question);
      
      optionsContainer.innerHTML = '';
      explanationBox.style.display = 'none';
      selfEvalContainer.innerHTML = '';
      retryContainer.innerHTML = '';

      const keys = Object.keys(q.options).sort();
      for (const key of keys) {
        const button = document.createElement('button');
        button.className = 'option-button';
        button.dataset.key = key;
        button.textContent = `${key}. ${q.options[key]}`;
        button.onclick = () => checkAnswer(key, q.answer);
        optionsContainer.appendChild(button);
      }
    }

    function checkAnswer(selectedKey, correctKey) {
      const buttons = optionsContainer.getElementsByTagName('button');
      for (let i = 0; i < buttons.length; i++) buttons[i].disabled = true;

      for (let i = 0; i < buttons.length; i++) {
        const key = buttons[i].dataset.key;
        if (key === correctKey) {
          buttons[i].classList.add('correct');
        } else if (key === selectedKey) {
          buttons[i].classList.add('incorrect');
        }
      }

      const q = currentQuestions[currentIndex];
      // === å•é¡Œã”ã¨ã®æ­£è§£/ä¸æ­£è§£ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–° ===
      if (!progress.stats) progress.stats = {};
      const stat = (progress.stats[q.id] = progress.stats[q.id] || { correct: 0, incorrect: 0 });
      const wasCorrect = (selectedKey === correctKey);
      if (wasCorrect) stat.correct++; else stat.incorrect++;
      flushProgress();
      const statNow = progress.stats && progress.stats[q.id] ? progress.stats[q.id] : { correct: 0, incorrect: 0 };
      const correctLabel = (q.options && q.options[correctKey]) ? `${correctKey}. ${q.options[correctKey]}` : String(correctKey);
      const selectedLabel = (q.options && q.options[selectedKey]) ? `${selectedKey}. ${q.options[selectedKey]}` : String(selectedKey);
      const nowPart = wasCorrect ? '[ä»Šå›] æ­£è§£' : '[ä»Šå›] ä¸æ­£è§£';
      const yourPart = (!wasCorrect && q.options && q.options[selectedKey]) ? `\n[ã‚ãªãŸã®å›ç­”] ${selectedLabel}` : '';
      explanationBox.textContent = `${q.explanation}\n${nowPart}\n[æ­£è§£] ${correctLabel}${yourPart}\n[ã“ã®å•é¡Œã®ç´¯è¨ˆ] æ­£è§£: ${statNow.correct} / ä¸æ­£è§£: ${statNow.incorrect}`;
      explanationBox.style.display = 'block';
      createSelfEvalButtons(); // å†å›ç­”ã§ã‚‚ãƒœã‚¿ãƒ³ã‚’å†åº¦ç”¨æ„
    }
    
    function createSelfEvalButtons() {
        selfEvalContainer.innerHTML = `
            <div class="self-eval-button perfect-btn" onclick="handleSelfEvaluation(STATUS.PERFECT)">å®Œç’§ï¼âœ¨</div>
            <div class="self-eval-button review-btn" onclick="handleSelfEvaluation(STATUS.REVIEW)">ã‚ã‚„ã—ã„â€¦ğŸ’¦</div>
        `;
        // ã™ãã«å¢—åˆ†ãŒè¦‹ãˆã‚‹ã‚ˆã†ã€åŒã˜å•é¡Œã‚’å†æŒ‘æˆ¦ã§ãã‚‹ãƒœã‚¿ãƒ³ã‚’ç”¨æ„
        retryContainer.innerHTML = `
            <button id="retry-btn" class="nav-btn" type="button">â†» ã‚‚ã†ä¸€åº¦ã“ã®å•é¡Œã‚’è§£ã</button>
        `;
        const rb = document.getElementById('retry-btn');
        if (rb && !rb.__bound) {
          rb.addEventListener('click', (e) => {
            e.preventDefault();
            retryCurrentQuestion();
          }, { passive: false });
          rb.__bound = true;
        }
    }

    function retryCurrentQuestion() {
      // åŒã˜å•é¡Œã‚’å‡ºã—ç›´ã™ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯é€²ã‚ãªã„ï¼‰
      const q = currentQuestions[currentIndex];
      if (!q) return;
      // å†æç”»
      setQuestionText(questionText, q.question);
      optionsContainer.innerHTML = '';
      explanationBox.style.display = 'none';
      selfEvalContainer.innerHTML = '';
      retryContainer.innerHTML = '';
      const keys = Object.keys(q.options).sort();
      for (const key of keys) {
        const button = document.createElement('button');
        button.className = 'option-button';
        button.dataset.key = key;
        button.textContent = `${key}. ${q.options[key]}`;
        button.onclick = () => checkAnswer(key, q.answer);
        optionsContainer.appendChild(button);
      }
    }

    function handleSelfEvaluation(status) {
      const q = currentQuestions[currentIndex];
      progress.statuses[q.id] = status;
      currentIndex++;
      flushProgress();
      displayQuestion();
    }

    function handleQuizEnd() {
      const remainCount = (ALL_QUESTIONS[currentSubject] || []).filter(q => q.type === 'choice' && progress.statuses[q.id] === STATUS.REVIEW).length;
      if (remainCount > 0) {
        if (confirm(`ãŠç–²ã‚Œæ§˜ï¼\nã¾ã ã€Œã‚ã‚„ã—ã„ã€å•é¡ŒãŒ ${remainCount} å•ã‚ã‚Šã¾ã™ã€‚ç¶šã‘ã¦å¾©ç¿’ã—ã¾ã™ã‹ï¼Ÿ`)) {
          progress.isReviewMode = true;
          currentIndex = 0;
          flushProgress();
          startQuiz(currentSubject);
          return;
        }
      }
      alert('å…¨å•çµ‚äº†ï¼ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼');
      showScreen('home');
    }

    // ===== æœ€å°ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆæœªå®šç¾©ãªã‚‰ç”¨æ„ï¼‰ =====
    if (typeof showScreen !== 'function') {
      function showScreen(screenName) {
        document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
        const el = document.getElementById(`${screenName}-screen`);
        if (el) el.style.display = 'block';
      }
    }
    if (typeof loadProgress !== 'function') {
      function loadProgress() {
        // ç§‘ç›®ã”ã¨ã®ä¿å­˜ã‚­ãƒ¼ã§å¾©å…ƒï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯åˆæœŸåŒ–ï¼‰
        const key = 'progress_' + currentSubject;
        try {
          const saved = localStorage.getItem(key);
          if (saved) {
            const s = JSON.parse(saved);
            progress = {
              statuses: (s && s.statuses) || {},
              isReviewMode: !!(s && s.isReviewMode),
              stats: (s && s.stats) || {}
            };
            currentIndex = Number.isInteger(s && s.currentIndex) ? s.currentIndex : 0;
          } else {
            progress = { statuses: {}, isReviewMode: false, stats: {} };
            currentIndex = 0;
          }
        } catch (e) {
          console.warn('é€²æ—ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', e);
          progress = { statuses: {}, isReviewMode: false, stats: {} };
          currentIndex = 0;
        }
      }
    }
    if (typeof flushProgress !== 'function') {
      function flushProgress() {
        const key = 'progress_' + currentSubject;
        try {
          const state = {
            statuses: progress.statuses || {},
            isReviewMode: !!progress.isReviewMode,
            currentIndex: currentIndex,
            stats: progress.stats || {}
          };
          localStorage.setItem(key, JSON.stringify(state));
        } catch (e) {
          console.warn('é€²æ—ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:', e);
        }
      }
    }

    // ===== åˆæœŸè¡¨ç¤ºï¼ˆDOMèª­ã¿è¾¼ã¿å¾Œã«HOMEã‚’å¿…ãšè¡¨ç¤ºï¼‰ =====
    document.addEventListener('DOMContentLoaded', () => {
      showScreen('home');
      bindHomeButtons();
      if (backHomeBtn && !backHomeBtn.__bound) {
        backHomeBtn.addEventListener('click', (e) => {
          e.preventDefault();
          flushProgress();
          showScreen('home');
        }, { passive: false });
        backHomeBtn.__bound = true;
      }
    });

  </script>
</body>
</html>